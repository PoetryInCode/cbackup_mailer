help = """cbackup_alert_mail.py

This script is designed to be run by a scheduler, like systemd. When run, it will connect to the specified database that CBackup uses and serch through logs from the past hour.
If it finds any logs that match the configured severity level(s), it will send an email to the configured recipient.

The program is configured through a .yml file provided by the user

FLAGS:
\t-h | --help
\t\tDisplays the current help message
\t-v | --version
\t\tDisplay version information
\t-c {FILE} | --config={FILE}
\t\tUses the file `FILE` as the config for the program"""

import mysql.connector
from enum import Enum
import yaml
import getopt
import sys
from smtplib import SMTP
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import functools


class LogSeverity(Enum):
    ALERT = "ALERT"
    CRITICAL = "CRITICAL"
    DEBUG = "DEBUG"
    EMERG = "EMERG"
    ERROR = "ERROR"
    INFO = "INFO"
    NOTICE = "NOTICE"
    WARNING = "WARNING"

    def all():
        return [EMERG, CRITICAL, ERROR, ALERT, WARNING, NOTICE, DEBUG, INFO]
    def reasonable():
        return [LogSeverity.EMERG, LogSeverity.CRITICAL, LogSeverity.ERROR, LogSeverity.ALERT, LogSeverity.WARNING, LogSeverity.NOTICE]
    
    def __str__(self):
        return self.value


class LogAction(Enum):
    TASK_START = "TASK START"
    TASK_FINISH = "TASK FINISH"
    WORKER_SEND_RESULT = "WORKER SEND RESULT"
    GIT_COMMIT = "GIT COMMIT"
    NODE_REQUEST = "NODE REQUEST"

    def __str__(self):
        return self.value


class Log:
    id, userid, time, severity, schedule_type = None, None, None, None, None
    schedule_id, node_id, action, message = None, None, None, None

    def __init__(self, tup):
        self.id = int(tup[0]) # The id of the log
        self.userid = str(tup[1]) # The id of the user that generated the log
        self.time = tup[2] # The time the log was generated
        self.severity = LogSeverity(tup[3]) # The severity level of the log
        self.schedule_type = str(tup[4]) # The type of task the log was generated by
        self.schedule_id = tup[5] # The scheduler that the log was generated by
        self.node_id = tup[6] # The node that generated the log
        self.action = LogAction(tup[7]) # The action performed when the log was generated
        self.message = str(tup[8]) # The log message
    
    def htmlify(self):
        return f"""\
<tr>
    <td>{self.id}</td>
    <td>{self.time}</td>
    <td>{self.severity}</td>
    <td>{self.node_id}</td>
    <td>{self.action}</td>
    <td><pre style="background-color:#E0E0E0; margin:1em; padding:0.5em">{self.message}</pre></td>
</tr>"""

    def __str__(self):
        return f"({self.id}, {self.userid}, {self.time}, {self.severity}, {self.schedule_type}, {self.schedule_id}, {self.node_id}, {self.action}, {self.message})"

def parse_yaml(file):
    conf = yaml.safe_load(file)
    try:
        dbc = conf["database"]
        db_host = dbc["host"]
        db_port = dbc["port"]
        db_user = dbc["user"]
        db_pass = dbc["password"]
        db_name = dbc["name"]

        dbm = conf["mail"]
        mail_host = dbm["host"]
        mail_port = dbm["port"]
        mail_from_email = dbm["from_email"]
        mail_from = dbm["from"]
        mail_to = dbm["to"]

        dbms = dbm["security"]
        mail_ssl = dbms["ssl"]
        mail_keyfile = dbms["keyfile"]
        mail_certfile = dbms["certfile"]

        levels = dbm["send_on"]

        return (db_host, db_port, db_user, db_pass, db_name, mail_host, mail_port, mail_from_email, mail_from, mail_to, mail_ssl, mail_keyfile, mail_certfile, levels)
    except KeyError:
        print("Malformed config file!")
        print("Exiting...")
        sys.exit(1)

def generate_mail(logs):
    alerts = [i.severity.name for i in logs]
    ldict = {i:alerts.count(i) for i in alerts}
    html = f"""\
<html>
    <body>
        <pre>
Summary:
In the past hour the following severity log(s) have been generated by CBackup:
{", ".join(map(lambda a: f"{a}x{ldict.get(a)}", ldict))}

Information on the logs can be found below:
        </pre>
        <table align="center" border="1" cellpadding="0" cellspacing="0" width="90%">
        <tr>
            <th>Log Id</th>
            <th>Time</th>
            <th>Severity</th>
            <th>Node Id</th>
            <th>Action</th>
            <th>Message</th>
        </tr>
        {"".join(map(Log.htmlify, logs))}
        </table>
    </body>
</html>"""
    msg = MIMEMultipart("alternative")
    msg.attach(MIMEText(html, _subtype="html", _charset="UTF-8"))
    return msg

if __name__ == "__main__":
    opts, args = getopt.getopt(
        sys.argv[1:],
        "vhc",
        ["version", "help", "config="])

    db_host = "localhost"
    db_user = "cbackup"
    db_passwd = None
    database = "cbackup"
    db_port = 3306

    mail_smtp_port = 25
    mail_from_email = None
    mail_from = "CBackup"
    mail_to = None
    mail_ssl = False
    mail_keyfile = None
    mail_certfile = None

    allowed_severity = LogSeverity.reasonable()

    has_config = False

    for o, a in opts:
        if o in ("-v", "--version"):
            print("Python: " + sys.version)
            sys.exit(0)
        elif o in ("-h", "--help"):
            print(help)
            sys.exit(0)
        elif o in ("-c", "--config"):
            with open(a, "r") as cf:
                db_host, db_port, db_user, db_passwd, db_name, mail_host, mail_port, mail_from_email, mail_from, mail_to, mail_ssl, mail_keyfile, mail_certfile, levels = parse_yaml(cf)
                has_config = True
            break
        else:
            pass
    
    if not has_config:
        print("A valid config file was not provided!")
        print("Exiting...")
        sys.exit(1)

    db = mysql.connector.connect(
        host=db_host,
        user=db_user,
        password=db_passwd,
        database=db_name,
        port=db_port)

    cursor = db.cursor()

    cursor.execute("select * from log_scheduler where DATE(time) >= date_sub(now(), interval 1 hour);")
    logs = map(Log, cursor.fetchall())

    db.close()

    if len(list(logs)) <= 0:
        print("No problems were detected")
        sys.exit(0)

    smtp = SMTP(
        host=mail_host,
        port=mail_port)

    if mail_ssl:
        smtp.starttls(
            certfile=mail_certfile,
            keyfile=mail_keyfile)

    alerts = [log for log in logs if log.severity in allowed_severity]
    mail = generate_mail(alerts)
    mail["From"] = f"{mail_from} <{mail_from_email}>"
    mail["To"] = mail_to
    mail["Subject"] = "CBackup Alerts"
    smtp.sendmail(mail_from_email, mail_to, mail.as_string())